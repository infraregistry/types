// Code generated by tygo. DO NOT EDIT.

//////////
// source: broker.go

export interface MessagePayload<T extends any> {
  payload?: T;
}
export interface BrokerStreamAnnounceAddedMessage<T extends any> {
  MessageIdentifiers: MessageIdentifiers;
  MessagePayload: MessagePayload<T>;
  session: string;
}
export interface BrokerStreamAnnounceRemovedMessage<T extends any> {
  MessageIdentifiers: MessageIdentifiers;
  MessagePayload: MessagePayload<T>;
  session: string;
}
export interface BrokerSendScopedMessage<T extends any> {
  MessageIdentifiers: MessageIdentifiers;
  MessagePayload: MessagePayload<T>;
}
export interface BrokerSessionsListMessage<T extends any> {
  MessageIdentifiers: MessageIdentifiers;
  MessagePayload: MessagePayload<T>;
}
export interface BrokerSessionsKillMessage<T extends any> {
  MessageIdentifiers: MessageIdentifiers;
  MessagePayload: MessagePayload<T>;
}

//////////
// source: client.go

export interface ClientMessage<T extends any> {
  correlationId?: string;
  method: Method;
  date: string /* RFC3339 */;
  scope?: Scope;
  context?: string;
  data?: T;
}

//////////
// source: common.go

export interface MessageCommHeartbeat {
  time: string /* RFC3339 */;
}
/**
 * Method is a type that is used to define the type of a websocket message.
 */
export type Method = string;
export const MethodPing: Method = "ping";
export interface PingEnvelope {
  time: string /* RFC3339 */;
}
export interface PingReply {
  delta: any /* time.Duration */;
}
export interface MessageIdentifiers {
  tenant: string;
  user?: string;
  session?: string;
}
/**
 * Message is a struct that holds the data of a websocket message.
 */
export interface Message {
  correlationId: string;
  result: boolean;
  type: MapKey;
  date: string /* RFC3339 */;
  data: any;
}
export type Scope = string;
export const ScopeGlobal: Scope = "global";
export const ScopeTenant: Scope = "tenant";
export const ScopeUser: Scope = "user";
export const ScopeSession: Scope = "session";
export const ScopeCamera: Scope = "camera";
export interface GenericMessage<T extends any> {
  session: Session;
  scope: Scope;
  context: string;
  type: MapKey;
  correlationId: string;
  date: string /* RFC3339 */;
  data: T;
}
export interface SSE<T extends any> {
  key: MapKey;
  context: string;
  data: T;
}
export interface GenericRequest<T extends any> {
  correlationId: string;
  session: Session;
  client: string;
  key: MapKey;
  data: T;
}
export interface Request {
  correlationId?: string;
  session?: Session;
  client?: string;
  key: MapKey;
  data?: any;
}
export interface GenericResponse<T extends any> {
  correlationId: string;
  result: boolean;
  data?: T;
}
export interface Response<T extends any> {
  correlationId: string;
  result: boolean;
  data?: T;
}
export type MapKey = string;
export interface Mapping {
  Namespace: string[];
}

//////////
// source: controller.go

export const ControllerRoutingKey = "controller";
export const ControllerDeploymentCreate: Method = "controller.deployment.create";
export const ControllerDeploymentDelete: Method = "controller.deployment.delete";
export type ControllerStatus = string;
export const ControllerStatusCreated: ControllerStatus = "created";
export const ControllerStatusCreating: ControllerStatus = "creating";
export const ControllerStatusRunning: ControllerStatus = "running";
export const ControllerStatusDeleted: ControllerStatus = "deleted";
export const ControllerStatusError: ControllerStatus = "error";
export interface ControllerDeploymentCreateMessage {
  camera: string;
  rtspUri: string;
}
export interface ControllerDeploymentDeleteMessage {
  camera: string;
  loadbalancerAddress: string;
  loadbalancerPort: number /* int */;
}
export interface ControllerDeploymentCreateResponseMessage {
  /**
   * NegotiationPort is the port number that the camera is configured
   * to use for WebRTC negotiation.
   */
  loadbalancerPort: number /* int */;
}

//////////
// source: internal.go

export interface InternalMessage<T extends any> {
  session: Session;
  correlationId?: string;
  method: Method;
  date: string /* RFC3339 */;
  scope?: Scope;
  context?: string;
  data?: T;
}

//////////
// source: media.go

export type MediaType = string;
export const MediaTypeVideo: MediaType = "video";
export const MediaTypeAudio: MediaType = "audio";

//////////
// source: sessions.go

export interface Session {
  ID: string;
  User: string;
  Tenant: string;
}

//////////
// source: sources.go

export type SourceStatus = number /* int */;
export const SourceStatusDisconnected: SourceStatus = 0;
export const SourceStatusReconnecting: SourceStatus = 1;
export const SourceStatusConnecting: SourceStatus = 2;
export const SourceStatusConnected: SourceStatus = 3;
export type SourceMediaType = number /* int */;
export const SourceMediaTypeVideo: SourceMediaType = 0;
export const SourceMediaTypeAudio: SourceMediaType = 1;
export interface Source {
  camera: string;
}
export interface SourcePacket {
  Camera: string;
  Type: SourceMediaType;
  Data: string;
}
export interface SourceList {
  tenant: string;
  camera: string;
  status: SourceStatus;
}
export interface MessageSourceList {
  tenant: string;
}
export interface MessageSourceCreate {
  camera: string;
  video: boolean;
  audio: boolean;
}
export interface MessageSourceRemove {
  camera: string;
}
export interface MessageSourceCreateResponse {
  hostname: string;
  comms: number /* int */;
  video: number /* int */;
  audio: number /* int */;
}

//////////
// source: streamer.go

export const StreamerBroadcastLease: Method = "streamer.broadcast.lease";
export const StreamerBroadcastRenew: Method = "streamer.broadcast.renew";
export const StreamerBroadcastUnlease: Method = "streamer.broadcast.unlease";
export type StreamerCapabilityType = string;
export const StreamerCapabilityTypeHLS: StreamerCapabilityType = "hls";
export const StreamerCapabilityTypeWebRTC: StreamerCapabilityType = "webrtc";
export interface StreamerCapability {
  type: StreamerCapabilityType;
  audio: boolean;
  video: boolean;
}
export interface StreamerBroadcastLeaseMessage {
  initiator: string;
  expires: string /* RFC3339 */;
  address: string;
  port: number /* int */;
  capability: StreamerCapability;
}
export interface StreamerBroadcastRenewMessage {
  initiator: string;
  expires: string /* RFC3339 */;
  capability: StreamerCapability;
}
export interface StreamerBroadcastUnleaseMessage {
  initiator: string;
  capability: StreamerCapability;
}
export interface StreamerBroadcastLeaseResultMessage {
  result: boolean;
  message: string;
  capability: StreamerCapability;
}

//////////
// source: streams.go

export type StreamStatus = string;
export const StreamStatusPlaying: StreamStatus = "playing";
export const StreamStatusPaused: StreamStatus = "paused";
export const StreamStatusRestarting: StreamStatus = "restarting";
export const StreamStatusError: StreamStatus = "error";
export type StreamRate = number /* int */;
export const StreamRateLow: StreamRate = 5;
export const StreamRateMedium: StreamRate = 10;
export const StreamRateHigh: StreamRate = 30;

//////////
// source: webrtc.go

export const WebRTCNegotiationInitiate: Method = "webrtc.negotiation.initiate";
export const WebRTCNegotiationOffer: Method = "webrtc.negotiation.offer";
export const WebRTCNegotiationAnswer: Method = "webrtc.negotiation.answer";
export const WebRTCNegotiationComplete: Method = "webrtc.negotiation.complete";
export const WebRTCNegotiationCandidate: Method = "webrtc.negotiation.candidate";
export const WebRTCStreamStart: Method = "webrtc.stream.start";
export const WebRTCStreamStop: Method = "webrtc.stream.stop";
export type WebRTCFeature = string;
export const WebRTCFeatureVideo: WebRTCFeature = "video";
export const WebRTCFeatureAudio: WebRTCFeature = "audio";
export const WebRTCFeatureRecording: WebRTCFeature = "recording";
export const WebRTCFeatureLive: WebRTCFeature = "live";
export const WebRTCFeatureHLS: WebRTCFeature = "hls";
export const WebRTCFeatureWebRTC: WebRTCFeature = "webrtc";
export type WebRTCStreamState = string;
export const WebRTCStreamStateStarted: WebRTCStreamState = "started";
export const WebRTCStreamStateStopped: WebRTCStreamState = "stopped";
/**
 * WebRTCSessionDescription is the session description for a WebRTC connection.
 */
export interface WebRTCSessionDescription {
  type: string;
  sdp: string;
}
/**
 * WebRTCNegotiationAnswerMessage is the answer to an offer.
 */
export interface WebRTCNegotiationAnswerMessage {
  answer: WebRTCSessionDescription;
}
/**
 * WebRTCNegotiationOfferMessage is the offer to be answered.
 */
export interface WebRTCNegotiationOfferMessage {
  offer: WebRTCSessionDescription;
}
/**
 * WebRTCNegotiationCompleteMessage is the message sent to complete the WebRTC negotiation process.
 */
export interface WebRTCNegotiationCompleteMessage {
  offer: WebRTCSessionDescription;
}
/**
 * WebRTCCandidateMessage is the message sent to send an ICE candidate.
 */
export interface WebRTCCandidateMessage {
  candidate: any /* webrtc.ICECandidateInit */;
}
/**
 * WebRTCStreamStartMessage is the message sent to start a live view of a camera.
 */
export interface WebRTCStreamStartMessage {
  camera: string;
  video: boolean;
  audio: boolean;
  fps: number /* int */;
  negotiation: WebRTCNegotiationOfferMessage;
}
/**
 * WebRTCStreamStartResponseMessage is the response to a WebRTCStreamStartMessage.
 */
export interface WebRTCStreamStartResponseMessage {
  negotiation: WebRTCNegotiationAnswerMessage;
}
/**
 * WebRTCStreamStopMessage is the message sent to stop a live view of a camera.
 */
export interface WebRTCStreamStopMessage {
  camera: string;
  negotiation: WebRTCNegotiationOfferMessage;
}
/**
 * WebRTCStreamStopResponseMessage is the response to a WebRTCStreamStartMessage.
 */
export interface WebRTCStreamStopResponseMessage {
  negotiation: WebRTCNegotiationAnswerMessage;
}
